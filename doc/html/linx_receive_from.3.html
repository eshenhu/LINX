<!-- manual page source format generated by PolyglotMan v3.0.8+X.Org, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>LINX_RECEIVE_FROM(3) manual page</title>
</head>
<body bgcolor='#efefef' text='black' link='blue' vlink='#551A8B' alink='red'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
linx_receive() - Receive a LINX signal <br>
linx_receive_w_tmo() - Receive a LINX signal with timeout <br>
linx_receive_from() - Receive a LINX signal, but only from a given endpoint

<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<b>#include &lt;linx_types.h&gt;</b> <br>
<b>#include &lt;linx.h&gt;</b> <br>

<p> <b>int linx_receive(LINX *</b><i>linx</i><b>, union LINX_SIGNAL **</b><i>sig</i><b>, const LINX_SIGSELECT
*</b><i>sig_sel</i><b>);</b> <br>

<p> <b>int linx_receive_w_tmo(LINX *</b><i>linx</i><b>, union LINX_SIGNAL **</b><i>sig</i><b>, LINX_OSTIME
</b><i>tmo</i><b>, const LINX_SIGSELECT *</b><i>sig_sel</i><b>);</b> <br>

<p> <b>int linx_receive_from(LINX *</b><i>linx</i><b>, union LINX_SIGNAL **</b><i>sig</i><b>, LINX_OSTIME
</b><i>tmo</i><b>, const LINX_SIGSELECT *</b><i>sig_sel</i><b>, LINX_SPID </b><i>from</i><b>);</b> <br>

<h2><a name='sect2' href='#toc2'>Description</a></h2>
Receives a LINX signal.  The calls will block until a signal
is received or, if applicable, a timeout has elapsed.  The first signal
in the receive queue that matches the <i>sig_sel</i> filter is returned to the
user. This way the user may process signals in a different order than when
they arrived at the LINX endpoint. Signals that have arrived but have not
yet been received using these calls will stay in the receive queue. <br>

<p> <b>linx_receive</b>() will wait indefinitely for a signal that matches the  <i>sig_sel</i>
filter.  <i>sig_sel</i> filters are described in  <a href='linx.7.html'><b>linx</b>(7)</a>
. <br>

<p> <b>linx_receive_w_tmo</b>() waits until the provided timeout, <i>tmo</i>, has elapsed
or for a signal that matches the <i>sig_sel</i> filter. When the timeout has elapsed,
zero is returned and <i>sig</i> is set to LINX_NIL instead of a pointer to a signal
buffer. <br>

<p> <b>linx_receive_from</b>() works in the same way as <b>linx_receive_w_tmo</b>() except
that it will only accept signals sent from the LINX endpoint, indicated
by the spid <i>from</i>. <br>

<p> <i>linx</i> is the handle to the LINX endpoint, via which the signals are received.
<br>

<p> <i>sig</i> is the received signal. The signal buffer is allocated by <a href='linx_receive.3.html'><b>linx_receive</b>(3)</a>
.
Never use a preallocated signal buffer as it will be lost. <br>

<p> <i>sig_sel</i> is a select filter, defining which types of buffers to receive.
It is a list of signal numbers with a leading count indicating the number
of signal numbers in the list. If the first position is set to a negative
count, all signal numbers except those listed will be received. Read more
about select filters in  <a href='linx.7.html'><b>linx</b>(7)</a>
. <br>

<p> <i>tmo</i> is the maximum number of milliseconds to wait. The value 0 will result
in a check for a signal matching <i>sig_sel</i> followed by an immediate return.
<br>

<p> <i>from</i> is the spid of the other LINX endpoint to receive from. Before  <b>linx_receive_from</b>()
is used, it is important to attach to the other LINX endpoint with <a href='linx_attach.3.html'><b>linx_attach</b>(3)<b></b></a>

and also to include the attach signal number in the  <i>sig_sel</i> filter. If
this is not done and the other LINX endpoint (with spid <i>from</i> ) is closed,
this call will block the entire specified timeout. 
<p> 
<h2><a name='sect3' href='#toc3'>Return Value</a></h2>
Returns
the size of the received signal in bytes if successful. If a signal was
received, it can be found in <i>sig</i>, otherwise  <i>sig</i> will be LINX_NIL. Returns
0 if <a href='linx_receive_w_tmo.3.html'><b>linx_receive_w_tmo</b>(3)</a>
 was called and no message was received before
the timeout. 
<p> If unsuccessful, -1 is returned and  <i>errno</i> is set. 
<h2><a name='sect4' href='#toc4'>Errors</a></h2>

<p> <b>ENOMEM</b>
if there is not enough memory. <br>

<p> <b>EBADF</b>, <b>EFAULT</b>, <b>ENOTCONN</b>, <b>ENOTSOCK</b> if the underlying <i>linx</i> structure contains
a invalid socket descriptor. <br>

<p> <b>EINTR</b> the call was interrupted by a signal. <br>

<p>
<p> 
<p> 
<h2><a name='sect5' href='#toc5'>Bugs/Limitations</a></h2>
None. 
<p> 
<h2><a name='sect6' href='#toc6'>Notes</a></h2>

<p> In case the application needs to wait on
multiple sockets of different kinds, the internal socket descriptor in
a LINX endpoint can be fetched with <a href='linx_get_descriptor.3.html'><b>linx_get_descriptor</b><i>(3)</i></a>
 and used in
a  <a href='select.2.html'><b>select</b><i>(2)</i></a>
 or  <a href='poll.2.html'><b>poll</b><i>(2)</i></a>
 call to wake up if anything arrives at the LINX
endpoint. 
<p> 
<h2><a name='sect7' href='#toc7'>Example</a></h2>
In this example the server sends four signals to the client
and the client chooses to receive them in the order it wants to. 
<p> <br>
<pre>Signal file (example.sig):
#include &lt;linx.h&gt;
#define SIG_X 0x1
#define SIG_Y 0x2
#define SIG_Z 0x3
#define SIG_W 0x4
/* select filter is { number-of-signals, signal, signal, ... } */
static const LINX_SIGSELECT sigsel_any[]      = { 0 };
static const LINX_SIGSELECT sigsel_sig_x_z[]  = { 2, SIG_X, SIG_Z };
static const LINX_SIGSELECT sigsel_sig_w[]    = { 1, SIG_W };
Server:
#include &lt;linx.h&gt;
#include "example.sig"
int
main (int argc, char *argv[])
{
  LINX *linx;
  LINX_SPID client;
  union LINX_SIGNAL *sig;
  /* Open a linx endpoint with huntname "server" */
  linx = linx_open("server", NULL, 0);
  /* Hunt for client */
  linx_hunt(linx, "client", NULL);
  /* Receive hunt signal */
  linx_receive(linx, &amp;sig, LINX_OS_HUNT_SIG);
  /* Retrieve client's spid */
  client = linx_sender(linx, &amp;sig);
  /* Free the hunt signal */
  linx_free_buf(linx, &amp;sig);
  /*  Send four signals, they will be stored in the receive
   *  queue on the client in same order as sent but the
   *  client chooses in which order to retrieve them from
   *  the queue.
   */
  /* Send signal with signal number SIG_X */
  sig = linx_alloc(linx, sizeof(LINX_SIGSELECT), SIG_X);  
  linx_send(linx, &amp;sig, client);
  /* Send signal with signal number SIG_Y */
  sig = linx_alloc(linx, sizeof(LINX_SIGSELECT), SIG_Y);  
  linx_send(linx, &amp;sig, client);
  /* Send signal with signal number SIG_Z */
  sig = linx_alloc(linx, sizeof(LINX_SIGSELECT), SIG_Z);  
  linx_send(linx, &amp;sig, client);
  /* Send signal with signal number SIG_W */
  sig = linx_alloc(linx, sizeof(LINX_SIGSELECT), SIG_W);  
  linx_send(linx, &amp;sig, client);
  linx_free_buf(linx, &amp;sig);
  /* Close the linx endpoint */
  linx_close (linx);
}
Client:
#include &lt;linx.h&gt;
#include "example.sig"
int
main (int argc, char *argv[])
{
  LINX *linx;
  LINX_SPID client;
  /* Open a linx endpoint with huntname "client" */
  linx = linx_open("client", NULL, 0);
  /* Check for signal SIG_W first */  
  linx_receive(linx, &amp;sig, sigsel_sig_w);
  /* Do work, sig-&gt;sig_no is SIG_W */
  /* Free signal when done */
  linx_free_buf(linx, &amp;sig);
  /* Receive the the first signal waiting in the receive queue */
  linx_receive(linx, &amp;sig, sigsel_any);
  /* Do work, sig-&gt;sig_no is SIG_X */
  linx_free_buf(linx, &amp;sig);
  /* Receive either SIG_X or SIG_Z from the receive queue. */ 
  linx_receive(linx, &amp;sig, sigsel_sig_x_z);
  /* Do work, sig-&gt;sig_no is SIG_Z (SIG_X has been consumed) */
  linx_free_buf(linx, &amp;sig);
  /* Receive the the first signal waiting in the receive queue */
  linx_receive(linx, &amp;sig, sigsel_any);
  /* Do work, sig-&gt;sig_no is SIG_Y */
  linx_free_buf(linx, &amp;sig);
  linx_close (linx);
}
</pre>
<p> 
<h2><a name='sect8' href='#toc8'>See Also</a></h2>
<a href='linx.7.html'><b>linx</b>(7)</a>
, <a href='linx_hunt.3.html'><b>linx_hunt</b>(3)</a>
, <a href='linx_send.3.html'><b>linx_send</b>(3)</a>
,  <a href='linx_sender.3.html'><b>linx_sender</b>(3)</a>
, <a href='linx_free_buf.3.html'><b>linx_free_buf</b>(3)</a>
,
<a href='linx_alloc.3.html'><b>linx_alloc</b>(3)</a>
,  <a href='linx_get_descriptor.3.html'><b>linx_get_descriptor</b>(3)</a>
,  <a href='poll.2.html'><b>poll</b>(2)</a>
, <a href='select.2.html'><b>select</b>(2)</a>
 
<h2><a name='sect9' href='#toc9'>Author</a></h2>
Enea
LINX team 
<h2><a name='sect10' href='#toc10'>Copyright</a></h2>

<p> Copyright (c) 2006-2007, Enea Software AB All rights
reserved. <br>

<p> Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met: <br>

<p> Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer. Redistributions in
binary form must reproduce the above copyright notice, this list of conditions
and the following disclaimer in the documentation and/or other materials
provided with the distribution. Neither the name of Enea Software AB nor
the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission. <br>

<p> THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE. <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Return Value</a></li>
<li><a name='toc4' href='#sect4'>Errors</a></li>
<li><a name='toc5' href='#sect5'>Bugs/Limitations</a></li>
<li><a name='toc6' href='#sect6'>Notes</a></li>
<li><a name='toc7' href='#sect7'>Example</a></li>
<li><a name='toc8' href='#sect8'>See Also</a></li>
<li><a name='toc9' href='#sect9'>Author</a></li>
<li><a name='toc10' href='#sect10'>Copyright</a></li>
</ul>
</body>
</html>
