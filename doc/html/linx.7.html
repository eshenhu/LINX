<!-- manual page source format generated by PolyglotMan v3.0.8+X.Org, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>LINX(7) manual page</title>
</head>
<body bgcolor='#efefef' text='black' link='blue' vlink='#551A8B' alink='red'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
linx - LINX inter-process communication protocol 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<b>#include &lt;linx.h&gt;</b>
<br>
<b>#include &lt;linx_socket.h&gt;</b> <br>
<b>#include &lt;linx_ioctl.h&gt;</b> <br>
<b>#include &lt;linx_types.h&gt;</b> <br>
<b>#include &lt;sys/socket.h&gt;</b> <br>
<b>#include &lt;sys/ioctl.h&gt;</b> 
<p> 
<h2><a name='sect2' href='#toc2'>Description</a></h2>

<p> <b>LINX</b> is a location transparent inter-process
communication protocol. It is based on the message passing technology used
in the Enea OSE family of real time operating systems. <p>
LINX consists of
a set of kernel modules and provides a standard socket based interface
using its own protocol family, <b>PF_LINX.</b> There is also a LINX library that
provides a more advanced messaging API. Applications normally access LINX
through this library, but sometimes direct access via the socket interface
may be necessary. <p>

<p> 
<h2><a name='sect3' href='#toc3'>Linx Concepts</a></h2>

<p> An application that wants to communicate
using LINX must first create a <b>LINX endpoint.</b> One thread may own multiple
LINX endpoints simultaneously. A LINX endpoint is created with a non-unique
name (a string). A handle which is used to refer to the endpoint in subsequent
calls is returned to the application. 
<p> LINX endpoints communicate by sending
and receiving <b>LINX signals.</b> The properties of LINX signals are described
below. 
<p> Each LINX endpoint has a binary identifier called a  <b>spid</b> which
is unique within the node. A sending endpoint must know the spid of the
destination endpoint to be able to communicate. The spid of a peer LINX
endpoint is normally obtained by <b>hunting</b> for its name. When an endpoint
with a matching name is found or created, LINX sends a hunt signal back
to the hunting endpoint that appears to have been sent from the found endpoint.
The spid can thus be obtained by looking at the sender of this signal. 
<p>
A LINX endpoint can supervise, or <b>attach</b> to, the spid of a peer endpoint
in order to be notified by a LINX signal when it is terminated or becomes
unreachable. 
<p> The communication path between two LINX nodes is called a
<b>LINX link.</b> A LINX link is created with a name string, and the same link
may have different names on the opposite nodes, i.e. the link between nodes
A and B may be called "LinkToB" on A, and "LinkToA" on B. 
<p> When hunting
for an endpoint on a remote node, the name of the endpoint is prepended
with the path of link names needed to reach the node, e.g. "LinkToB/LinkToC/EndpointName".
LINX will create a virtual endpoint that acts as a local representation
of the remote endpoint. LINX signals sent to the spid of a virtual endpoint
are automatically routed to the proper destination on the remote node. 
<p>
When a LINX endpoint is closed, its owned LINX signals are freed. 
<p> It is
not allowed to use a LINX endpoint from two contexts at the same time. When
a Linux process has multiple threads, it is not allowed to access a LINX
endpoint from other contexts than the one that opened it. When <a href='fork.2.html'><b>fork</b>(2)</a>
 is
called, the child process inherits copies of the parents socket related
resources, including LINX endpoints. In this case, either the parent or
the child shall close its LINX endpoints. A LINX endpoint is not removed
until it has been closed by all of its owners. 
<p> 
<p> 
<h2><a name='sect4' href='#toc4'>LINX Application Interfaces</a></h2>

<p>
LINX provides both a standard socket interface and a more advanced <b>LINX
API</b> which is available through the LINX library, to be linked with the
application. The LINX API is the recommended way for applications to access
LINX, since it simplifies for the programmer by abstracting the direct
socket interactions. It implements a set of functions specified in <a href='linx.h.3.html'><b>linx.h</b>(3)</a>
.
<p>
The LINX socket interface is the underlying socket implementation provided
by the LINX kernel module and is used by the LINX library. It is described
in detail below. <p>
It is possible for applications to use a combination of
the LINX API and the LINX socket interface. In this case, the LINX API function
<a href='linx_get_descriptor.3.html'><b>linx_get_descriptor</b>(3)</a>
 can be used to obtain the socket descriptor of a
LINX endpoint. This descriptor can be used together with other file descriptors
in generic <a href='poll.2.html'><b>poll</b>(2)</a>
 or <a href='select.2.html'><b>select</b>(2)</a>
 calls. Note that it is NOT allowed to call
<a href='close.2.html'><b>close</b>(2)</a>
 on a LINX socket descriptor obtained by a <a href='linx_get_descriptor.3.html'><b>linx_get_descriptor</b>(3)</a>

call. 
<p> 
<p> 
<h2><a name='sect5' href='#toc5'>LINX Signals</a></h2>

<p> A LINX signal consists of a mandatory leading 4-byte
signal number, optionally followed by data. Thus, the size of a LINX signal
buffer must be at least 4 bytes. LINX signal numbers are of type <b>LINX_SIGSELECT.</b>
Signal numbers are mainly defined by the applications, but a few values
are not allowed. Zero (0) is illegal and must not be used and 250-255 are
reserved by LINX. <p>
LINX provides endian conversion of the signal number if
needed when a signal is sent to a remote node. The signal data is not converted.

<p> 
<h2><a name='sect6' href='#toc6'>LINX Socket Interface</a></h2>

<p> The LINX socket interface allows application programmers
to access LINX using standard socket calls. It should be noted that only
a subset of the socket calls are implemented and that additional features
have been made available through ioctl calls. These deviations and features
are described below. <p>

<dl>

<dt><b>struct sockaddr_linx</b> </dt>
<dd>When using the socket interface
directly, a LINX endpoint is represented by a <b>sockaddr_linx</b> structure:

<p> <br>
<pre>struct sockaddr_linx
{
        sa_family_t family;
        LINX_SPID   spid;
};
</pre><br>

<p> <b>family</b> shall be  <b>AF_LINX</b> and <b>spid</b> is the spid of the LINX endpoint. The
<b>sockaddr_linx</b> structure is type-casted into a generic <b>sockaddr</b> structure
when passed to the socket interface function calls. 
<p> <br>
</dd>
</dl>
<p>

<p> The following calls are provided by the LINX socket interface: 
<p> 
<dl>

<dt><b>socket()</b>
</dt>
<dd>A LINX socket is created by calling the <a href='socket.2.html'><b>socket</b>(2)</a>
 function as: 
<p> <b>linx_sd
= socket(</b><i>PF_LINX</i><b>, </b><i>SOCK_DGRAM</i><b>, 0)</b><i>;</i> 
<p> When a LINX socket is created, its name
is unspecified. To assign a name to the socket, use the <b>LINX_IOCTL_HUNTNAME</b>
ioctl request. 
<p> On success, the return value is a descriptor referencing
the socket. On error, -1 is returned and  <i>errno</i> is set to one of the following
values: 
<p> <b>EPROTONOTSUPPORTED</b> <br>
The protocol type is not supported. Only <b>PF_LINX</b> is accepted. 
<p> <b>ESOCKTNOSUPPORT</b>
<br>
The socket type is not supported. Only <b>SOCK_DGRAM</b> is accepted. 
<p> <b>ENOMEM</b> <br>
Insufficient memory is available. Alternatively, the maximum number of spids
has been reached. This value is configurable as a parameter to the LINX
kernel module, see LINX Users Guide for more information. </dd>
</dl>
<p>

<p> 
<p> 
<dl>

<dt><b>sendto()</b> </dt>
<dd>The
<a href='sendto.2.html'><b>sendto</b>(2)</a>
 function is called as: 
<p> <b>len = sendto(</b><i>linx_sd</i><b>, </b><i>payload</i><b>, </b><i>size</i><b>,
0, (struct </b><i>sockaddr</i><b>*) &amp;</b><i>sockaddr_linx</i><b>, sizeof(struct </b><i>sockaddr_linx</i><b>));</b> 
<p> The
<i>payload</i> shall be a LINX signal buffer and <i>size</i> shall be its length in bytes.
Note that it is mandatory for a LINX signal to have a leading 4 byte signal
number. The <i>spid</i> field of the <i>sockaddr_linx</i> structure shall be the spid
of the destination endpoint. 
<p> On success, the number of bytes sent is returned.
On error, -1 is returned and <i>errno</i> is set to one of the following values:

<p> <b>EBADF</b> <br>
An invalid descriptor was specified. 
<p> <b>ECONNRESET</b> <br>
The destination endpoint has been killed. 
<p> <b>EINVAL</b> <br>
Invalid argument passed. 
<p> <b>ENOMEM</b> <br>
Insufficient memory is available. 
<p> <b>EOPNOTSUPP</b> <br>
The sending LINX socket has not been assigned a name. 
<p> <b>EPIPE</b> <br>
This error is reported at an attempt to send to the spid of a LINX endpoint
that is being closed as the call occurs. </dd>
</dl>
<p>

<p> 
<dl>

<dt><b>sendmsg()</b> </dt>
<dd>The <a href='sendmsg.2.html'><b>sendmsg</b>(2)</a>
 function
is called as: 
<p> <b>len = sendmsg(</b><i>linx_sd</i><b>, </b><i>*msg</i><b>,  0);</b> 
<p> <i>msg</i> is a <b>msghdr</b> structure
as defined in <a href='sendmsg.2.html'><b>sendmsg</b>(2)</a>
. The <i>msg_iov</i> field of the msghdr structure shall
point to an <b>iovec</b> structure containing the LINX signal buffer to transmit
and the <i>msg_iovlen</i> field shall be set to 1. Note that it is mandatory for
a LINX signal to have a leading 4 byte signal number. The <i>msg_name</i> field
shall be a pointer to a <b>sockaddr_linx</b> structure containing the spid of
the destination endpoint and the <i>msg_namelen</i> field shall be set to the
size of the sockaddr_linx structure. The ancillary fields and the flags
field of the msghdr structure shall not be used and be set to zero. 
<p> On
success, the number of bytes sent is returned. On error, -1 is returned and
<i>errno</i> is set to one of the following values: 
<p> <b>EBADF</b> <br>
An invalid descriptor was specified. 
<p> <b>ECONNRESET</b> <br>
The destination endpoint has been killed. Note that this case is accepted
and the signal is silently discarded by LINX. 
<p> <b>EINVAL</b> <br>
Invalid argument passed. 
<p> <b>ENOMEM</b> <br>
Insufficient memory is available. 
<p> <b>EOPNOTSUPP</b> <br>
The sending socket has not been assigned a name. 
<p> <b>EPIPE</b> <br>
This error is reported at an attempt to send to the spid of a LINX endpoint
that is being closed as the call occurs. </dd>
</dl>
<p>

<p> 
<p> 
<dl>

<dt><b>recvfrom()</b> </dt>
<dd>The <a href='recvfrom.2.html'><b>recvfrom</b>(2)</a>
 function
is called as: 
<p> <b>len = recvfrom(</b><i>linx_sd</i><b>, </b><i>payload</i><b>, </b><i>size</i><b>, 0, (struct </b><i>sockaddr</i><b>*)
&amp;</b><i>sockaddr_linx</i><b>, sizeof(struct </b><i>sockaddr_linx</i><b>));</b> 
<p> It is used to receive any
LINX signal from any LINX endpoint. It can not be used when signal number
filtering and/or sender filtering is needed, see <a href='recvmsg.2.html'><b>recvmsg</b>(2)</a>
. The first signal
in the sockets receive queue is returned in the supplied <i>payload</i> buffer.
If no signal is currently available at the socket, the call blocks until
a signal is received. The sender of the signal is returned in the <b>sockaddr_linx</b>
structure. Note that the <i>size</i> of the payload buffer must be at least 4 bytes,
since it is mandatory for a LINX signal to have a 4 byte leading signal
number. <br>

<p> On success, the number of bytes received is returned. If the received signal
is larger than the supplied payload buffer, zero is returned and the signal
buffer size is written as a 32-bit value in the first 4 bytes of the payload
buffer. On error, -1 is returned and <i>errno</i> is set to one of the following
values: 
<p> <b>EBADF</b> <br>
An invalid descriptor was specified. 
<p> <b>EFAULT</b> <br>
Invalid payload buffer pointer provided. 
<p> <b>EINVAL</b> <br>
Invalid argument passed. 
<p> <b>ENOMEM</b> <br>
Insufficient memory is available. 
<p> <b>EOPNOTSUPP</b> <br>
The receiving socket has not been assigned a name. </dd>
</dl>
<p>

<p> 
<dl>

<dt><b>recvmsg()</b> </dt>
<dd>The <a href='recvmsg.2.html'><b>recvmsg</b>(2)</a>

function is called as: 
<p> <b>len = recvmsg(</b><i>sd</i><b>, </b><i>msg</i><b>,  0);</b> 
<p> <i>msg</i> is a pointer to
a <b>msghdr</b> structure as defined in <a href='recvmsg.2.html'><b>recvmsg</b>(2)</a>
. A LINX signal buffer shall
be supplied in an <b>iovec</b> structure pointed to from the <i>msg_iov</i> field and
the <b>msg_iovlen</b> field shall be set to 1. Note that the size of the supplied
buffer must be at least 4 bytes, since it is mandatory for a LINX signal
to have a 4 byte leading signal number. <br>

<p> The  <a href='recvmsg.2.html'><b>recvmsg</b>(2)</a>
 call supports signal number filtering and sender filtering.
This allows the user to specify which signal numbers shall be received
and/or from which sender. The signal filter is described by a <b>linx_receive_filter_param</b>
structure: 
<p> <br>
<pre>struct linx_receive_filter_param
{
        LINX_SPID             from;
        LINX_OSBUFSIZE        sigselect_size;
        const LINX_SIGSELECT *sigselect;
};
</pre>
<p> The <b>from</b> field specifies that only signals from a specific spid should
be received and <b>sigselect</b> is an array of <b>LINX_SIGSELECT</b> numbers to be received.
The first position in the array contains the number of entries in the list
that follows. If the first position is set to a negative count, all LINX
signals except those listed will be received. The size of the array is <b>sigselect_size.</b>
<br>

<p> The filtering uses ancillary fields in the <b>msghdr</b> structure and is described
by the following example code: 
<p> <br>
<pre>struct msghdr msg;
char cmsg[CMSG_SPACE(sizeof(struct linx_receive_filter_param))];
struct linx_receive_filter_param * rfp;
struct iovec iov;
const LINX_SIGSELECT sig_sel[] = { 1, EXAMPLE_SIG };
rfp = ((struct linx_receive_filter_param *)
        (CMSG_DATA(((struct cmsghdr *)cmsg))));
rfp-&gt;sigselect_size = sizeof(sig_sel);
rfp-&gt;from = from_spid;
rfp-&gt;sigselect = sig_sel;
msg.msg_name = (void*)&amp;linx_addr;
msg.msg_namelen = sizeof(struct sockaddr_linx);
msg.msg_iov = &amp;iov;
msg.msg_iovlen = 1;
msg.msg_flags = 0;
msg.msg_control = cmsg;
msg.msg_controllen =
        CMSG_SPACE(sizeof(struct linx_receive_filter_param));
((struct cmsghdr *)cmsg)-&gt;cmsg_len = msg.msg_controllen;
((struct cmsghdr *)cmsg)-&gt;cmsg_level = 0;
((struct cmsghdr *)cmsg)-&gt;cmsg_type = 0;
iov.iov_base = *signal;
iov.iov_len = sigsize;
read_size = recvmsg(linx-&gt;socket, &amp;msg, 0);
</pre>
<p> On success, the number of bytes received is returned. If the received signal
is larger than the supplied payload buffer, zero is returned and the signal
buffer size is written as a 32-bit value in the first 4 bytes of the payload
buffer. On error, -1 is returned and <i>errno</i> is set to one of the following
values: 
<p> <b>EBADF</b> <br>
An invalid descriptor was specified. 
<p> <b>EFAULT</b> <br>
An invalid msghdr structure was provided. 
<p> <b>EINVAL</b> <br>
Invalid argument passed. 
<p> <b>ENOMEM</b> <br>
Insufficient memory is available. 
<p> <b>EOPNOTSUPP</b> <br>
The sending socket has not been assigned a name. <br>

<p> </dd>

<dt><b>poll()</b> </dt>
<dd>LINX socket descriptors can be used in the <a href='poll.2.html'><b>poll</b>(2)</a>
 call. 
<p> The call
returns a bitmask that indicates the state of the LINX socket receive queues.
The following possible bits can be set at return from this function:  <b>POLLERR</b>
if the LINX socket is in an error state, <b>POLLHUP</b> if the LINX socket has
been shutdown/released, <b>POLLIN</b> and <b>POLLRDNORM</b> if the LINX socket has data
to read in receive queue. <br>

<p> </dd>

<dt><b>select()</b> </dt>
<dd>LINX socket descriptors can be used together with other file
descriptors in the <a href='select.2.html'><b>select</b>(2)</a>
 call. <br>

<p> </dd>

<dt><b>ioctl()</b> </dt>
<dd>IOCTL requests are sent to a LINX socket using the <a href='ioctl.2.html'><b>ioctl</b>(2)</a>
 call.
See below for all IOCTL request codes supported by LINX sockets. <br>

<p> </dd>

<dt><b>close()</b> </dt>
<dd>A LINX socket created by a <a href='socket.2.html'><i>socket</i>(2)</a>
 call can be closed with <a href='close.2.html'><i>close</i>(2)</a>
.
Note that this function shall NOT be used on any LINX socket descriptor
created with <a href='linx_open.3.html'><i>linx_open</i>(3)</a>
 or obtained by the LINX API function <a href='linx_get_descriptor.3.html'><i>linx_get_descriptor</i>(3)</a>
.
<br>

<p> On success, 0 is returned, otherwise -1 is returned and  <i>errno</i> can be one
of the following errors: 
<p> <b>EBADF</b> <br>
An invalid descriptor was specified. </dd>
</dl>
<p>

<p> Only the calls described above are
supported by a LINX socket.  The following are NOT supported on LINX sockets
and shall not be used: <a href='bind.2.html'><i>bind</i>(2)</a>
, <a href='connect.2.html'><i>connect</i>(2)</a>
, <a href='socketpair.2.html'><i>socketpair</i>(2)</a>
, <a href='accept.2.html'><i>accept</i>(2)</a>
, <a href='getname.2.html'><i>getname</i>(2)</a>
,
 <a href='listen.2.html'><i>listen</i>(2)</a>
, <a href='shutdown.2.html'><i>shutdown</i>(2)</a>
, <a href='setsockopt.2.html'><i>setsockopt</i>(2)</a>
, <a href='getsockopt.2.html'><i>getsockopt</i>(2)</a>
,  <a href='mmap.2.html'><i>mmap</i>(2)</a>
 and <a href='sendpage.2.html'><i>sendpage</i>(2)</a>
.

<p>
<p> 
<p> 
<h2><a name='sect7' href='#toc7'>IOCTL Request Codes</a></h2>
The following IOCTL request codes can be accessed
using <a href='ioctl.2.html'><i>ioctl</i>(2)</a>
 on LINX sockets: <br>

<p> <b>LINX_IOCTL_SEND</b> <br>
<blockquote>Sends a signal from a LINX socket <b>sd</b>. The correct syntax is: 
<p> <br>
<pre><b>struct linx_sndrcv_param *</b><i>sndrcv</i><b>;</b>

<i>error</i><b> = ioctl(</b><i>sd</i><b>, </b><i>LINX_IOCTL_SEND</i><b>, </b><i>sndrcv</i><b>);
</pre>
<p></b> <p>
<i>sndrcv</i> is a <b>linx_sndrcv_param</b> structure: <blockquote><br>
<pre>struct linx_sndrcv_param
{
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;__u32 from;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;__u32 to;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;__u32 size;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;__u32 sig_attr;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;__u32 sigselect_size;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;__u64 sigselect;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;__u32 tmo;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;__u64 buffer;
};
</pre><p>
</blockquote>
<b>from</b> is the spid of the sender, the sender does not need to be the current
socket, the signal is sent from the current socket but the receiver will
see the <b>from</b> as the sending spid, the default case is that <b>from</b> is the
spid of the current LINX socket. <b>to</b> is the spid of the receiver, <b>size</b> is
the size of the signal to be sent and <b>sig_attr</b> are the attributes of the
signal. The <b>sigselect_size</b> and <b>sigselect</b> are not used by <b>LINX_IOCTL_SEND</b>
and <b>notused</b> is for padding the struct since it needs to be 64-bit aligned
but should be zeroed for future use. <b>buffer</b> is the pointer to the buffer
to be sent, it is passed as a 64 bit unsigned value to be both 32-bit and
64-bit compatible. 
<p> On success, the number of bytes sent is returned. <br>
<p>
</blockquote>

<p> <b>LINX_IOCTL_RECEIVE</b> <br>
<blockquote>Receives a signal on a LINX socket <b>sd</b>. The call will block until a signal
is received. The correct syntax is: 
<p> <br>
<pre><b>struct linx_sndrcv_param *</b><i>sndrcv</i><b>;</b>

<i>error</i><b> = ioctl(</b><i>sd</i><b>, </b><i>LINX_IOCTL_RECEIVE</i><b>, </b><i>sndrcv</i><b>);
</pre>
<p></b> <p>
<i>sndrcv</i> is a <b>linx_sndrcv_param</b> structure: <blockquote><br>
<pre>struct linx_sndrcv_param
{
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;__u32 from;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;__u32 to;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;__u32 size;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;__u32 sig_attr;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;__u32 sigselect_size;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;__u64 sigselect;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;__u32 tmo;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;__u64 buffer;
};
</pre><p>
</blockquote>
The  <b>from</b> field should be set to <b>LINX_ILLEGAL_SPID</b> if signals from anyone
should be received or if only signals from a specific spid should be received
then <b>from</b> should be set to that spid. If <b>LINX_ILLEGAL_SPID</b> was set the <b>from</b>
will contain the spid of the sender after the return of the call. The <b>to</b>
field is not used when receiving a signal. The <b>size</b> field is the size of
the provided buffer. When the call returns the <b>sig_attr</b> field is set to
the attribute the signal carriers. The <b>sigselect</b> field is an array of <b>LINX_SIGSELECT</b>
numbers to be received. The first position in the array contains the number
of entries in the list that follows. If the first position is set to a negative
count, all LINX signals except those listed will be received. The size of
the array is <b>sigselect_size.</b> When the <b>tmo</b> field is used the call waits maximum
<b>tmo</b> milliseconds before returning even if no signal has been received,
if a blocking receive is requested the <b>tmo</b> field should be ~0 (0xFFFFFFFF),
this will block forever. If no signal is received the. <b>buffer</b> pointer will
be set to NULL (the provided buffer is always consumed). The <b>buffer</b> field
is a pointer to the buffer provided by the user. 
<p> On success, the number
of bytes received  is  returned.  If  the received signal is larger than
the supplied payload buffer, zero is returned and the signal buffer size
is written as a 32-bit value in the first 4 bytes of the payload buffer.
<br>
<p>
</blockquote>

<p> <b>LINX_IOCTL_REQUEST_TMO</b> <br>
<blockquote>Request a timeout, a signal is sent to the requesting LINX endpoint when
a timeout has expired. The correct syntax is: 
<p> <br>
<pre><b>struct linx_tmo_param *</b><i>tmo_param</i><b>;</b>

<i>error</i><b> = ioctl(</b><i>sd</i><b>, </b><i>LINX_IOCTL_REQUEST_TMO</i><b>, </b><i>tmo_param</i><b>);
</pre>
<p></b> <p>
<i>tmo_param</i> is a <b>linx_tmo_param</b> structure: <blockquote><br>
<pre>struct linx_tmo_param
{
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;LINX_OSTIME tmo;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;LINX_OSBUFSIZE sigsize;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;union LINX_SIGNAL *sig;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;LINX_OSTMOREF tmoref;
};
</pre><p>
</blockquote>
<b>tmo</b> is the timeout in milliseconds and the actual timeout time is rounded
upward to the nest larger tick, the call guarantees at least the number
of milliseconds requested, <b>sig</b> is a pointer to the signal that will be
returned when the timeout expires, if <b>sig</b> is LINX_NIL then the default
timeout signal with signal number LINX_OS_TMO_SIG is received instead,
<b>sigsize</b> is the size of the provided signal, if no signal is provided the
value must be set to zero. 
<p> On success, an timemout reference is returned
in <b>tmoref</b>. This reference can be used in <b>LINX_IOCTL_CANCEL_TMO</b> and <b>LINX_IOCTL_MODIFY_TMO</b>.
</blockquote>
<p>

<p> <b>LINX_IOCTL_CANCEL_TMO</b> <br>
<blockquote>Cancel a pending timeout, the correct syntax is: 
<p> <br>
<pre><b>struct linx_tmo_param *</b><i>tmo_param</i><b>;</b>

<i>error</i><b> = ioctl(</b><i>sd</i><b>, </b><i>LINX_IOCTL_CANCEL_TMO</i><b>, </b><i>tmo_param</i><b>);
</pre>
<p></b> <p>
<i>tmo_param</i> is a <b>linx_tmo_param</b> structure: <blockquote><br>
<pre>struct linx_tmo_param
{
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;LINX_OSTIME tmo;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;LINX_OSBUFSIZE sigsize;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;union LINX_SIGNAL *sig;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;LINX_OSTMOREF tmoref;
};
</pre><p>
</blockquote>
<b>tmo</b>, <b>sigsize</b> and <b>sig</b> are ignored, <b>tmoref</b> is used to identify which timeout
is to be canceled, it is guaranteed that the timeout signal cannot be received
after cancellation. </blockquote>
<p>

<p> <b>LINX_IOCTL_MODIFY_TMO</b> <br>
<blockquote>Modifies a pending timeout, the correct syntax is: 
<p> <br>
<pre><b>struct linx_tmo_param *</b><i>tmo_param</i><b>;</b>

<i>error</i><b> = ioctl(</b><i>sd</i><b>, </b><i>LINX_IOCTL_MODIFY_TMO</i><b>, </b><i>tmo_param</i><b>);
</pre>
<p></b> <p>
<i>tmo_param</i> is a <b>linx_tmo_param</b> structure: <blockquote><br>
<pre>struct linx_tmo_param
{
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;LINX_OSTIME tmo;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;LINX_OSBUFSIZE sigsize;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;union LINX_SIGNAL *sig;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;LINX_OSTMOREF tmoref;
};
</pre><p>
</blockquote>
<b>sigsize</b> and <b>sig</b> are ignored, <b>tmoref</b> is used to identify which timeout is
to be modified, <b>tmo</b> is the new timeout value. </blockquote>
<p>

<p> <b>LINX_IOCTL_REQUEST_NEW_LINK</b>
<br>
<blockquote>Request a signal when a new link is available, the correct syntax is: 
<p>
<br>
<pre><b>struct linx_new_link_param *</b><i>new_link_param</i><b>;</b>

<i>error</i><b> = ioctl(</b><i>sd</i><b>, </b><i>LINX_IOCTL_REQUEST_NEW_LINK</i><b>, </b><i>new_link_param</i><b>);
</pre>
<p></b> <p>
<i>new_link_param</i> is a <b>linx_new_link_param</b> structure: <blockquote><br>
<pre>struct linx_new_link_param
{
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;uint32_t token;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;uint32_t new_link_ref;
};
</pre><p>
</blockquote>
<b>token</b> is passed to and from the LINX kernel module keeping track of which
links the caller already have been notified about, the <b>token</b> value is ignored
the first time a LINX endpint requests a new link signal. The <b>token</b> received
in the new link signal should then be used in the next new link signal
request. <b>new_link_ref</b> is used to cancel a pending new link signal request.

<p> The syntax of the new link signal received when a new link is available
is: 
<p> <blockquote><br>
<pre>struct linx_new_link {
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;LINX_SIGSELECT signo;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;LINX_NLTOKEN token;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;int name;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;int attr;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;char buf[1];
};
</pre></blockquote>

<p> <b>signo</b> is LINX_OS_NEW_LINK_SIG, <b>token</b> is the token value to be used in
the next request for a new link signal, <b>name</b> is the offset into <b>buf</b> where
the name of the new link is stored, the name is null terminated, <b>attr</b> is
the offset into <b>buf</b> where the attributes, if any, of the link are stored,
the attribute string is null terminted, <b>buf</b> is a character buffer containg
the name and the attributes, if any, of the link. 
<p> </blockquote>
<p>

<p> 
<p> <b>LINX_IOCTL_CANCEL_NEW_LINK</b>
<br>
<blockquote>Cancels a pending new link signal request, the correct syntax is: 
<p> <br>
<pre><b>struct linx_new_link_param *</b><i>new_link_param</i><b>;</b>

<i>error</i><b> = ioctl(</b><i>sd</i><b>, </b><i>LINX_IOCTL_CANCEL_NEW_LINK</i><b>, </b><i>new_link_param</i><b>);
</pre>
<p></b> <p>
<i>new_link_param</i> is a <b>linx_new_link_param</b> structure: <blockquote><br>
<pre>struct linx_new_link_param
{
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;uint32_t token;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;uint32_t new_link_ref;
};
</pre><p>
</blockquote>
<b>token</b> is ignored, <b>new_link_ref</b> is used to identify which pending new link
signal request is to be cancelled, after the cancellation it is guarnateed
that no more new link signals can be received. </blockquote>
<p>

<p> <b>LINX_IOCTL_HUNTNAME</b> <br>
<blockquote>Sets the name of a LINX socket <b>sd</b> and returns its binary LINX endpoint
identifier, the spid. The correct syntax is: 
<p> <br>
<pre><b>struct linx_huntname *</b><i>huntname</i><b>;</b>

<i>error</i><b> = ioctl(</b><i>sd</i><b>, </b><i>LINX_IOCTL_HUNTNAME</i><b>, </b><i>huntname</i><b>);
</pre>
<p></b> <p>
<i>huntname</i> is a <b>linx_huntname</b> structure: <blockquote><br>
<pre>struct linx_huntname
{
        LINX_SPID spid;
        size_t    namelen; 
        char     *name;    
};
</pre><p>
</blockquote>
<b>namelen</b> is the size in bytes of the string  <b>name</b> that contains the name
to assign to the socket.  On success, <b>spid</b> is set to the spid assigned to
the LINX socket. <br>
<p>
</blockquote>

<p> <b>LINX_IOCTL_HUNT</b> <br>
<blockquote>Hunts for a LINX endpoint (that has been assigned a name) to obtain its
spid. The correct syntax is: 
<p> <br>
<pre><b>struct linx_hunt_param *</b><i>hunt_param</i><b>;</b>

<i>error</i><b> = ioctl(</b><i>sd</i><b>, </b><i>LINX_IOCTL_HUNT</i><b>, </b><i>hunt_param</i><b>);
</pre><br>
<p>
</b><i>hunt_param</i> is a  <b>linx_hunt_param</b> structure: <p>
<blockquote><br>
<pre>struct linx_hunt_param
{
        LINX_OSBUFSIZE     sigsize;
        union LINX_SIGNAL *sig;     
        LINX_SPID          from;    
        size_t             namelen; 
        char              *name;                                    
};
</pre><p>
</blockquote>
The <b>sig</b> parameter optionally holds a signal of size <b>sigsize</b> to be received
when the other LINX socket is available. If no signal (NULL) is provided,
the LINX default hunt signal of type <b>LINX_OS_HUNT_SIG</b> will be used. The
<b>from</b> parameter shall be set to the owner of the hunt. In the normal case,
this is the spid of the LINX socket performing the hunt call. If the spid
associated with a different LINX socket is provided, the hunt can be cancelled
by closing that socket. The hunt signal is always sent to the LINX socket
performing the hunt call. The <b>namelen</b> is the size of the string <b>name</b> that
contains the name of the LINX endpoint to be hunted for. </blockquote>
<p>

<p> <b>LINX_IOCTL_ATTACH</b>
<br>
<blockquote>Attaches to a LINX endpoint in order to supervise it, i.e. to get an attach
signal if it becomes unavailable. The correct syntax is: <br>

<p> <br>
<pre><b>struct linx_attach_param *</b><i>attach_param</i><b>;</b>

<i>error</i><b> = ioctl(</b><i>sd</i><b>, </b><i>LINX_IOCTL_ATTACH</i><b>, </b><i>attach_param</i><b>);
</pre>
<p></b> <br>
<p>
<i>attach_param</i> is a  <b>linx_attach_param</b> structure: <p>
<blockquote><br>
<pre>struct linx_attach_param
{
        LINX_SPID          spid;   
        LINX_OSBUFSIZE     sigsize;                                
        union LINX_SIGNAL *sig;    
        LINX_OSATTREF      attref; 
};
</pre><p>
</blockquote>
The <b>spid</b> field is the spid of the LINX endpoint to supervise. The <b>sig</b> parameter
optionally holds a LINX signal of size <b>sigsize</b> to be received when the
supervised LINX endpoint becomes unavailable. If no signal (NULL) is provided,
the LINX default attach signal of type <b>LINX_OS_ATTACH_SIG</b> will be used.
<br>

<p> On success, an attach reference is returned in <b>attref.</b> This reference can
be used in <b>LINX_IOCTL_DETACH</b> later. </blockquote>
<p>

<p> <b>LINX_IOCTL_DETACH</b> <br>
<blockquote>Detaches from a supervised LINX endpoint, i.e. stops supervising it. The correct
syntax is: </blockquote>

<p> <blockquote><br>
<pre><b>struct linx_detach_param *</b><i>detach_param</i><b>;</b>

<i>error</i><b> = ioctl(</b><i>sd</i><b>, </b><i>LINX_IOCTL_DETACH</i><b>, </b><i>detach_param</i><b>);
</pre><br>
<p>
</b>The <i>detach_param</i> parameter is a  <b>struct linx_detach_param</b> with the following
fields: <p>
<blockquote><br>
<pre>struct linx_detach_param
{
        LINX_OSATTREF  attref;
}
</pre><br>
<p>
</blockquote>
The <b>attref</b> field is an attach reference returned from a <b>LINX_IOCTL_ATTACH</b>
call. </blockquote>
<p>

<p> <b>LINX_IOCTL_SET_RECEIVE_FILTER</b> <br>
<blockquote>Sets up a receive filter prior to a <a href='select.2.html'><b>select</b>(2)</a>
 call. The correct syntax is:
</blockquote>

<p> <blockquote><br>
<pre><b>struct linx_receive_filter_param *</b><i>rfp</i><b>;</b>

<i>error</i><b> = ioctl(</b><i>sd</i><b>, </b><i>LINX_IOCTL_SET_RECEIVE_FILTER</i><b>, </b><i>rfp</i><b>);
</pre><br>
<p>
</b><i>rfp</i> is a <b>linx_receive_filter_param</b> structure: <p>
<blockquote><br>
<pre>struct linx_receive_filter_param
{
        LINX_SPID             from;          
        LINX_OSBUFSIZE        sigselect_size;
        const LINX_SIGSELECT *sigselect;     
};
</pre><br>
<p>
</blockquote>
The <b>from</b> parameter specifies that only signals from a specific spid should
be received and <b>sigselect</b> is an array of <b>LINX_SIGSELECT</b> numbers to be received.
The first position in the array contains the number of entries in the list
that follows. If the first position is set to a negative count, all LINX
signals except those listed will be received. The size of the array is <b>sigselect_size.</b>
</blockquote>
<p>

<p> <b>LINX_IOCTL_REGISTER_LINK_SUPERVISOR</b> <br>
<blockquote>This command is now obsolete; use the LINX_IOCTL_REQUEST_NEW_LINK instead.
</blockquote>

<p> <b>LINX_IOCTL_UNREGISTER_LINK_SUPERVISOR</b> <br>
<blockquote>This command is now obsolete; use the LINX_IOCTL_CANCEL_NEW_LINK instead.
</blockquote>
<p>

<p> <b>LINX_IOCTL_VERSION</b> <br>
<blockquote>Returns the version of the LINX kernel module. The correct syntax is: </blockquote>

<p> <blockquote><br>
<pre><b>unsigned int </b><i>version</i><b>;</b>

<i>error</i><b> = ioctl(</b><i>sd</i><b>, </b><i>LINX_IOCTL_VERSION</i><b>, &amp;</b><i>version</i><b>);
</pre><br>
<p>
</b>On success, the <b>version</b> parameter contains the version of the LINX kernel
module. The LINX version number is a 32-bit number composed of an 8-bit major
version, an 16-bit minor version, and a 8-bit seq (patch) number. </pre><br>
</blockquote>
<p>

<p>
<p> 
<p> <b>LINX_IOCTL_INFO</b> <br>
<blockquote>Retrieves information from the LINX kernel module. The correct syntax is:
</blockquote>

<p> <blockquote><br>
<pre><b>struct linx_info </b><i>info</i><b>;</b>

<i>error</i><b> = ioctl(</b><i>sd</i><b>, </b><i>LINX_IOCTL_INFO</i><b>, &amp;</b><i>info</i><b>);
</pre><br>
<p>
</b>The <b>info</b> parameter is a <b>struct linx_info</b> with the following fields: <p>
<blockquote><br>
<pre>struct linx_info
{
        int    type;
        void  *type_spec;
};
</pre><br>
<p>
</blockquote>
The <b>type</b> field indicates the requested type of information and <b>type_spec</b>
is a pointer to a struct that will contain input and return parameters.
<br>

<p> Note that information retrieved with LINX_IOCTL_INFO may have become inaccurate
when used in a subsequent call. The application must be prepared to handle
errors related to this. <br>

<p> The different kinds of information that can be retrieved from the LINX
kernel module are: <br>

<p> <b>LINX_INFO_SUMMARY</b> <br>
<blockquote><br>
Provides a summary of the most important information from the LINX kernel
module. </blockquote>

<p> <blockquote><br>
<pre><b>struct linx_info </b><i>info</i><b>;</b>

<b>struct linx_info_summary </b><i>info_summary</i><b>;</b>

<b>info.type = </b><i>LINX_INFO_SUMMARY</i><b>;</b>

<b>info.type_spec = </b><i>&amp;info_summary</i><b>;</b>
</pre><br>
<p>
The  <b>linx_info_summary</b> structure is defined as: <p>
<blockquote><br>
<pre>struct linx_info_summary
{
       int no_of_local_sockets;
       int no_of_remote_sockets;
       int no_of_link_sockets;
       int no_of_pend_attach;
       int no_of_pend_hunt;
       int no_of_queued_signals;
};
</pre><br>
<p>
</blockquote>
The <b>no_of_local_sockets</b> field is the number of LINX sockets open locally,
<b>no_of_remote_sockets</b> is the number of internal sockets open that have been
created by the LINX kernel module to represent remote LINX endpoints. The
<b>no_of_link_sockets</b> field is the number of open sockets representing LINX
links to other nodes. The <b>no_of_pend_attach</b> field is the number of pending
attaches, <b>no_of_pend_hunt</b> is the number of pending hunts and <b>no_of_queued_signals</b>
is the number of queued signals. </blockquote>
<br>

<p> <b>LINX_INFO_SOCKETS</b> <br>
<blockquote><br>
Returns the number of open LINX sockets and their LINX endpoint identifiers
(spids). </blockquote>

<p> <blockquote><br>
<pre><b>struct linx_info </b><i>info</i><b>;</b>

<b>struct linx_info_sockets </b><i>info_sockets</i><b>;</b>

<b>info.type = </b><i>LINX_INFO_SOCKETS</i><b>;</b>

<b>info.type_spec = </b><i>&amp;info_sockets</i><b>;</b>
</pre><br>
<p>
The <b>linx_info_sockets</b> structure is defined as: <p>
<blockquote><br>
<pre>struct linx_info_sockets
{
        LINX_OSBOOLEAN local;
        LINX_OSBOOLEAN remote;
        LINX_OSBOOLEAN link;
        int            buffer_size;
        int            no_of_sockets;
        LINX_SPID     *buffer;
};
</pre><br>
<p>
</blockquote>
If <b>local</b> is true, local sockets are included in the output, if <b>remote</b> is
true, remote sockets are included and if <b>link</b> is true, sockets representing
LINX links are included. The number of LINX sockets matching the search
is returned in <b>no_of_sockets</b> and the array of spids is returned in the
provided <b>buffer</b>. of size <b>buffer_size</b> bytes. If the provided buffer is too
small, not all sockets will be included. </blockquote>
<br>

<p> <b>LINX_INFO_TYPE</b> <br>
<blockquote><br>
Returns the type of a LINX endpoint. </blockquote>

<p> <blockquote><br>
<pre><b>struct linx_info </b><i>info</i><b>;</b>

<b>struct linx_info_type </b><i>info_type</i><b>;</b>

<b>info.type = </b><i>LINX_INFO_TYPE</i><b>;</b>

<b>info.type_spec = </b><i>&amp;info_type</i><b>;</b>
</pre><br>
<p>
The <b>linx_info_type</b> structure is defined as: <p>
<blockquote><br>
<pre>struct linx_info_type
{
        LINX_SPID  spid;
        int        type;
};
</pre><br>
<p>
</blockquote>
The <b>spid</b> field is the identifier of the LINX endpoint for which the type
is requested. The type is returned in <b>type</b>. A LINX endpoint can be of types:
<b>LINX_TYPE_UNKNOWN</b>, <b>LINX_TYPE_LOCAL</b>, <b>LINX_TYPE_REMOTE</b>, <b>LINX_TYPE_LINK</b>, <b>LINX_TYPE_ILLEGAL</b>
or <b>LINX_TYPE_ZOMBIE</b>. </blockquote>
<br>

<p> <b>LINX_INFO_STATE</b> <br>
<blockquote><br>
Returns the state of a LINX endpoint. </blockquote>

<p> <blockquote><br>
<pre><b>struct linx_info </b><i>info</i><b>;</b>

<b>struct linx_info_state </b><i>info_state</i><b>;</b>

<b>info.type = </b><i>LINX_INFO_STATE</i><b>;</b>

<b>info.type_spec = </b><i>&amp;info_state</i><b>;</b>
</pre><br>
<p>
The <b>linx_info_state</b> structure is defined as: <p>
<blockquote><br>
<pre>struct linx_info_state
{
        LINX_SPID  spid;
        int        state;
};
</pre><br>
<p>
</blockquote>
The <b>spid</b> field is the identifier of the LINX endpoint for which the state
is requested. The state is returned in <b>state</b>. A LINX socket can be in states:
<b>LINX_STATE_UNKNOWN</b>, <b>LINX_STATE_RUNNING</b>, <b>LINX_STATE_RECV</b> or <b>LINX_STATE_POLL</b>.
</blockquote>
<br>

<p>
<p> 
<p> <b>LINX_INFO_FILTERS</b> <br>
<blockquote><br>
Returns information about the receive filters set up by a LINX endpoint.
</blockquote>

<p> <blockquote><br>
<pre><b>struct linx_info </b><i>info</i><b>;</b>

<b>struct linx_info_filters </b><i>info_filters</i><b>;</b>

<b>info.type = </b><i>LINX_INFO_FILTERS</i><b>;</b>

<b>info.type_spec = </b><i>&amp;info_filters</i><b>;</b>
</pre><br>
<p>
The <b>linx_info_filters</b> structure is defined as: <p>
<blockquote><br>
<pre>struct linx_info_filters
{
        LINX_SPID       spid;           
        LINX_SPID       from_filter;
        int             buffer_size;
        int             no_of_sigselect;
        LINX_SIGSELECT *buffer;         
};
</pre><br>
<p>
</blockquote>
The <b>spid</b> field is the identifier of the LINX endpoint for which the receive
filter is requested. If the endpoint has setup a receive filter only accepting
signals from a specific LINX endpoint, the spid of that endpoint is returned
in <b>from_filter</b>. The number of LINX_SIGSELECT signal numbers in the receive
filter is returned in <b>no_of_sigselect</b>. A copy of the filter of the LINX
endpoint is returned in <b>buffer</b>. The first element of the filter is the amount
of LINX_SIGSELECT that follow it. <br>
<b>buffer_size</b> is the size in bytes of the buffer. If the buffer is too small,
not all  signal numbers in the filter are included. It is possible to know
whether all LINX_SIGSELECT were copied to the <b>buffer</b> array by comparing
its first element with <b>no_of_sigselect</b>. </blockquote>
<br>

<p> <b>LINX_INFO_RECV_QUEUE</b> <br>
<blockquote><br>
Returns the receive queue of a LINX endpoint. </blockquote>

<p> <blockquote><br>
<pre><b>struct linx_info </b><i>info</i><b>;</b>

<b>struct linx_info_recv_queue </b><i>info_recv_queue</i><b>;</b>

<b>info.type = </b><i>LINX_INFO_RECV_QUEUE</i><b>;</b>

<b>info.type_spec = </b><i>&amp;info_recv_queue</i><b>;</b>
</pre><br>
<p>
The <b>linx_info_recv_queue</b> structure is defined as: <p>
<blockquote><br>
<pre>struct linx_info_recv_queue
{
        LINX_SPID                spid;           
        int                      buffer_size;    
        int                      no_of_signals;  
        struct linx_info_signal *buffer;
};
</pre><br>
<p>
</blockquote>
The <b>spid</b> field is the identifier of the LINX endpoint for which the receive
queue is requested. The number of signals in the queue is returned in <b>no_of_signals</b>.
An array with queue information is returned in the provided <b>buffer</b>. The
<b>buffer_size</b> is the size in bytes of the buffer. If the buffer is too small,
not all  signals are included. The <b>linx_info_signal</b> structure is defined
as: <p>
<blockquote><br>
<pre>struct linx_info_signal
{
        LINX_SIGSELECT signo;
        int            size; 
        LINX_SPID      from; 
};
</pre><br>
<p>
</blockquote>
The <b>signo</b> field holds the signal number, <b>size</b> is the size in bytes of the
signal and <b>from</b> is the spid of the sending LINX endpoint.  </blockquote>
<br>

<p> <b>LINX_INFO_RECV_QUEUE_2</b> <br>
<blockquote><br>
Returns the receive queue of a LINX endpoint, with information about OOB
messages in queue. </blockquote>

<p> <blockquote><br>
<pre><b>struct linx_info </b><i>info</i><b>;</b>

<b>struct linx_info_recv_queue_2 </b><i>info_recv_queue</i><b>;</b>

<b>info.type = </b><i>LINX_INFO_RECV_QUEUE_2</i><b>;</b>

<b>info.type_spec = </b><i>&amp;info_recv_queue</i><b>;</b>
</pre><br>
<p>
The <b>linx_info_recv_queue</b> structure is defined as: <p>
<blockquote><br>
<pre>struct linx_info_recv_queue_2
{
        LINX_SPID  spid;           
        int        buffer_size;    
        int        no_of_signals;  
        char      *buffer;
};
</pre><br>
<p>
</blockquote>
The <b>spid</b> field is the identifier of the LINX endpoint for which the receive
queue is requested. The number of signals in the queue is returned in <b>no_of_signals</b>.
An array with queue information is returned in the provided <b>buffer</b>. The
<b>buffer_size</b> is the size in bytes of the buffer. If the buffer is too small,
not all  signals are included. The <b>linx_info_signal_2</b> structure is defined
as: <p>
<blockquote><br>
<pre>struct linx_info_signal_2
{
        LINX_SIGSELECT signo;
        int            size; 
        LINX_SPID      from; 
        uint32_t       flags;
};
</pre><br>
<p>
</blockquote>
The <b>signo</b> field holds the signal number, <b>size</b> is the size in bytes of the
signal and <b>from</b> is the spid of the sending LINX endpoint. <b>flags</b> specifies
the type of transmission. Values of this argument are formed by logically
OR'ing zero or more of the following flags: 
<p> <b>MSG_OOB</b> A signal sent out-of-band.
</blockquote>
<br>

<p>
<p> 
<p> <b>LINX_INFO_PEND_ATTACH</b> <br>
<blockquote><br>
Returns information about pending attaches  <b>from</b> or <b>to</b> a LINX endpoint.
</blockquote>

<p> <blockquote><br>
<pre><b>struct linx_info </b><i>info</i><b>;</b>

<b>struct linx_info_pend_attach </b><i>info_pend_attach</i><b>;</b>

<b>info.type = </b><i>LINX_INFO_PEND_ATTACH</i><b>;</b>

<b>info.type_spec = </b><i>&amp;info_pend_attach</i><b>;</b>
</pre><br>
<p>
The <b>linx_info_pend_attach</b> structure is defined as: <p>
<blockquote><br>
<pre>struct linx_info_pend_attach
{
        LINX_SPID                spid;      
        int                      from_or_to;
        int                      buffer_size;
        int                      no_of_attaches;
        struct linx_info_attach *buffer;        
};
</pre><br>
<p>
</blockquote>
The <b>spid</b> field is the identifier of the LINX endpoint for which attach
information is requested. If <b>from_or_to</b> is set to  <b>LINX_ATTACH_FROM,</b> information
about attaches from the spid is returned. If it is set to <b>LINX_ATTACH_TO,</b>
information about attaches to the spid is returned. The number of attaches
to/from the <b>spid</b> is returned in <b>no_of_attaches</b>, Information about the attaches
are returned in the provided <b>buffer</b>. The <b>buffer_size</b> is the size in bytes
of the buffer. If the buffer is too small, not all  attaches are included.
The <b>linx_info_attach</b> structure is defined as: <p>
<blockquote><br>
<pre>struct linx_info_attach
{
        LINX_SPID               spid;  
        LINX_OSATTREF           attref;
        struct linx_info_signal attach_signal;
};
</pre><br>
<p>
</blockquote>
The <b>spid</b> is the identifier of the LINX endpoint that has attached or has
been attached to (depending on what <b>from_or_to</b> is set to). The <b>attref</b> field
is the attach reference and <b>attach_signal</b> is the attach signal. </blockquote>
<br>

<p>
<p> 
<p> <b>LINX_INFO_PEND_HUNT</b> <br>
<blockquote><br>
Returns information about pending hunts issued from any LINX endpoint. <blockquote><br>
<pre><b>struct linx_info </b><i>info</i><b>;</b>

<b>struct linx_info_pend_hunt </b><i>info_pend_hunt</i><b>;</b>

<b>info.type = </b><i>LINX_INFO_PEND_HUNT</i><b>;</b>

<b>info.type_spec = </b><i>&amp;info_pend_hunt</i><b>;</b>
</pre><br>
</blockquote>

<p> The <b>linx_info_pend_hunt</b> structure is defined as: <p>
<blockquote><br>
<pre>struct linx_info_pend_hunt
{
        LINX_SPID              spid;          
        int                    buffer_size;   
        int                    strings_offset;
        int                    no_of_hunts;     
        struct linx_info_hunt *buffer;          
};
</pre><br>
<p>
</blockquote>
The <b>spid</b> field is the identifier of the LINX endpoint for which hunt information
is requested. The number of pending hunts is returned in <b>no_of_hunts</b> and
information about each pending hunt is returned in the provided <b>buffer</b>.
The <b>buffer_size</b> is the size in bytes of the buffer. If the buffer is too
small, not all  hunts are included. The <b>strings_offset</b> is the offset into
the <b>buffer</b> where the name strings are stored. Each <b>linx_info_hunt</b> structure
is defined as: <p>
<blockquote><br>
<pre>struct linx_info_hunt
{
        struct linx_info_signal hunt_signal;
        LINX_SPID               owner;      
        char                   *hunt_name;  
};
</pre><br>
<p>
</blockquote>
The <b>owner</b> field is the owner of the pending hunt and <b>hunt_name</b> is a string
containing the name hunted for. The <b>hunt_signal</b> is the hunt signal. The <b>linx_info_signal</b>
structure is described under <b>LINX_INFO_RECV_QUEUE</b>. </blockquote>
<br>

<p>
<p> 
<p> <b>LINX_INFO_PEND_TMO</b> <br>
<blockquote><br>
Returns information about pending timeouts issued from any LINX endpoint.
<blockquote><br>
<pre><b>struct linx_info </b><i>info</i><b>;</b>

<b>struct linx_info_pend_tmo </b><i>info_pend_tmo</i><b>;</b>

<b>info.type = </b><i>LINX_INFO_PEND_TMO</i><b>;</b>

<b>info.type_spec = </b><i>&amp;info_pend_tmo</i><b>;</b>
</pre><br>
</blockquote>

<p> The <b>linx_info_pend_tmo</b> structure is defined as: <p>
<blockquote><br>
<pre>struct linx_info_pend_tmo
{
        LINX_SPID             spid;
        int                   buffer_size;
        int                   no_of_timeouts;
        struct linx_info_tmo  *buffer;
};
</pre><br>
<p>
</blockquote>
The <b>spid</b> field is the identifier of the LINX endpoint for which timeout
information is requested. The number of pending timeouts is returned in
<b>no_of_timeouts</b> and information about each pending timeout is returned in
the provided <b>buffer</b>. The <b>buffer_size</b> is the size in bytes of the buffer.
If the buffer is too small, not all  timeouts are included. Each <b>linx_info_tmo</b>
structure is defined as: <p>
<blockquote><br>
<pre>struct linx_info_tmo
{
        LINX_OSTIME             tmo;
        LINX_OSTMOREF           tmoref;
        struct linx_info_signal tmo_signal;
};
</pre><br>
<p>
</blockquote>
The <b>tmo</b> field is the remaining time and <b>tmoref</b> is the timeout reference.
The <b>tmo_signal</b> holds the timeout signal information. </blockquote>
<br>

<p>
<p> 
<p> <b>LINX_INFO_SIGNAL_PAYLOAD</b> <br>
<blockquote><br>
Returns the payload of a signal owned by a LINX endpoint. <blockquote><br>
<pre><b>struct linx_info </b><i>info</i><b>;</b>

<b>struct linx_info_signal_payload </b><i>info_signal_payload</i><b>;</b>

<b>info.type = </b><i>LINX_INFO_SIGNAL_PAYLOAD</i><b>;</b>

<b>info.type_spec = </b><i>&amp;info_signal_payload</i><b>;</b>
</pre><br>
</blockquote>

<p> The <b>linx_info_signal_payload</b> structure is defined as: <p>
<blockquote><br>
<pre>struct linx_info_signal_payload
{
        LINX_SPID               spid;       
        int                     buffer_size;
        struct linx_info_signal signal;       
        int                     payload_size; 
        char                   *buffer;       
};
</pre><br>
<p>
</blockquote>
The <b>spid</b> field is the identifier of the LINX endpoint owning the signal
and <b>signal</b> is a  <b>linx_info_signal</b> structure returned from a previous LINX_INFO
call. The signal buffer will be returned in the provided <b>buffer</b>. The <b>buffer_size</b>
is the size in bytes of the buffer. If the provided buffer is too small,
only the beginning of the signal buffer is returned. The <b>payload_size</b> shows
the size in bytes of the returned signal payload. If the provided buffer
is larger than the signal payload,  <b>payload_size</b> will be less than <b>buffer_size</b>.
If no signal payload matching the <b>signal</b> the <b>payload_size</b> will be set to
zero. </blockquote>
<br>

<p>
<p> 
<p> <b>LINX_INFO_NAME</b> <br>
<blockquote><br>
Returns the name of a LINX endpoint. </blockquote>

<p> <blockquote><br>
<pre><b>struct linx_info </b><i>info</i><b>;</b>

<b>struct linx_info_name </b><i>info_name</i><b>;</b>

<b>info.type = </b><i>LINX_INFO_NAME</i><b>;</b>

<b>info.type_spec = </b><i>&amp;info_name</i><b>;</b>
</pre><br>
<p>
The <b>linx_info_name</b> structure is defined as: <p>
<blockquote><br>
<pre>struct linx_info_name
{
        LINX_SPID spid;   
        int       namelen;
        char     *name;   
};
</pre><br>
<p>
</blockquote>
The <b>spid</b> field is the identifier of the LINX endpoint for which the name
is requested. The  <b>namelen </b> field is the length of the provided <b>name</b> buffer
in which the name is returned. If the LINX socket endpoint has not been
assigned a name yet zero is returned and <b>name</b> is set to the empty string.
</blockquote>
<br>

<p>
<p> 
<p> <b>LINX_INFO_OWNER</b> <br>
<blockquote><br>
Returns the process (PID) that owns a LINX endpoint. </blockquote>

<p> <blockquote><br>
<pre><b>struct linx_info </b><i>info</i><b>;</b>

<b>struct linx_info_owner </b><i>info_owner</i><b>;</b>

<b>info.type = </b><i>LINX_INFO_OWNER</i><b>;</b>

<b>info.type_spec = </b><i>&amp;info_owner</i><b>;</b>
</pre><br>
<p>
The <b>linx_info_owner</b> structure is defined as: <p>
<blockquote><br>
<pre>struct linx_info_owner
{
        LINX_SPID spid; 
        pid_t     owner;
};
</pre><br>
<p>
</blockquote>
The <b>spid</b> field is the identifier of the LINX endpoint for which the information
is requested. On success, the PID of the owning process is returned in <b>owner</b>.
</blockquote>
<br>

<p>
<p> 
<p> <b>LINX_INFO_STAT</b> <br>
<blockquote><br>
Returns statistics for a LINX endpoint. This requires that the LINX kernel
module has been compiled with the "SOCK_STAT=yes" setting. </blockquote>
<blockquote><br>
<pre><b>struct linx_info </b><i>info</i><b>;</b>

<b>struct linx_info_stat </b><i>info_stat</i><b>;</b>

<b>info.type = </b><i>LINX_INFO_STAT</i><b>;</b>

<b>info.type_spec = </b><i>&amp;info_stat</i><b>;</b>
</pre><br>
<p>
The <b>linx_info_stat</b> structure is defined as: <p>
<blockquote><br>
<pre>struct linx_info_stat
{
        LINX_SPID spid;
        uint64_t no_sent_local_signals;
        uint64_t no_recv_local_signals;
        uint64_t no_sent_local_bytes;
        uint64_t no_recv_local_bytes;
        uint64_t no_sent_remote_signals;
        uint64_t no_recv_remote_signals;
        uint64_t no_sent_remote_bytes;
        uint64_t no_recv_remote_bytes;
        uint64_t no_sent_signals;
        uint64_t no_recv_signals;
        uint64_t no_sent_bytes;
        uint64_t no_recv_bytes;
        uint64_t no_queued_bytes;
        uint64_t no_queued_signals;
};
</pre><br>
<p>
</blockquote>
The <b>spid</b> is the identifier of the LINX endpoint for which statistics is
required. If the LINX kernel module has not been compiled with "SOCK_STAT=yes",
ioctl returns -1 and errno is set to ENOSYS. </blockquote>
<br>

<p>
<p> 
<p> </blockquote>

<h2><a name='sect8' href='#toc8'>Known Bugs</a></h2>
None. 
<h2><a name='sect9' href='#toc9'>See Also</a></h2>
Generic LINX for Linux man-page: <br>
<a href='linx.7.html'><b>linx</b>(7)</a>
 (this document) <br>

<p> LINX API man-pages: <br>
<a href='linx.h.3.html'><b>linx.h</b>(3)</a>
,  <a href='linx_types.h.3.html'><b>linx_types.h</b>(3)</a>
,  <br>
<a href='linx_alloc.3.html'><b>linx_alloc</b>(3)</a>
,  <a href='linx_attach.3.html'><b>linx_attach</b>(3)</a>
,  <a href='linx_cancel_tmo.3.html'><b>linx_cancel_tmo</b>(3)</a>
,  <a href='linx_close.3.html'><b>linx_close</b>(3)</a>
,  <br>
<a href='linx_detach.3.html'><b>linx_detach</b>(3)</a>
,  <a href='linx_free_buf.3.html'><b>linx_free_buf</b>(3)</a>
,  <a href='linx_free_name.3.html'><b>linx_free_name</b>(3)</a>
,  <a href='linx_free_stat.3.html'><b>linx_free_stat</b>(3)</a>
,
 <br>
<a href='linx_get_descriptor.3.html'><b>linx_get_descriptor</b>(3)</a>
,  <a href='linx_get_name.3.html'><b>linx_get_name</b>(3)</a>
,  <a href='linx_get_spid.3.html'><b>linx_get_spid</b>(3)</a>
,  <br>
<a href='linx_get_stat.3.html'><b>linx_get_stat</b>(3)</a>
,  <a href='linx_hunt.3.html'><b>linx_hunt</b>(3)</a>
,  <a href='linx_hunt_from.3.html'><b>linx_hunt_from</b>(3)</a>
,  <a href='linx_modify_tmo.3.html'><b>linx_modify_tmo</b>(3)</a>
,
 <br>
<a href='linx_open.3.html'><b>linx_open</b>(3)</a>
,  <a href='linx_receive.3.html'><b>linx_receive</b>(3)</a>
,  <a href='linx_receive_from.3.html'><b>linx_receive_from</b>(3)</a>
,  <br>
<a href='linx_receive_w_tmo.3.html'><b>linx_receive_w_tmo</b>(3)</a>
,  <a href='linx_request_tmo.3.html'><b>linx_request_tmo</b>(3)</a>
,  <a href='linx_send.3.html'><b>linx_send</b>(3)</a>
,  <a href='linx_send_w_opt.3.html'><b>linx_send_w_opt</b>(3)</a>
,
 <br>
<a href='linx_send_w_s.3.html'><b>linx_send_w_s</b>(3)</a>
,  <a href='linx_sender.3.html'><b>linx_sender</b>(3)</a>
,  <a href='linx_set_sigsize.3.html'><b>linx_set_sigsize</b>(3)</a>
,  <a href='linx_sigattr.3.html'><b>linx_sigattr</b>(3)</a>
,
 <a href='linx_sigsize.3.html'><b>linx_sigsize</b>(3)</a>
 <br>

<p> Related LINX applications <br>
<a href='linxcfg.1.html'><b>linxcfg</b>(1)</a>
,  <a href='linxdisc.8.html'><b>linxdisc</b>(8)</a>
,  <a href='linxdisc.conf.5.html'><b>linxdisc.conf</b>(5)</a>
,  <a href='linxstat.1.html'><b>linxstat</b>(1)</a>
,  <a href='mkethcon.1.html'><b>mkethcon</b>(1)</a>
,
 <a href='mklink.1.html'><b>mklink</b>(1)</a>
,  <a href='mktcpcon.1.html'><b>mktcpcon</b>(1)</a>
,  <a href='rmethcon.1.html'><b>rmethcon</b>(1)</a>
,  <a href='rmlink.1.html'><b>rmlink</b>(1)</a>
,  <a href='rmtcpcon.1.html'><b>rmtcpcon</b>(1)</a>
 <br>

<p> Related generic Linux man-pages: <br>
<a href='socket.2.html'><b>socket</b>(2)</a>
, <a href='close.2.html'><b>close</b>(2)</a>
,  <a href='sendto.2.html'><b>sendto</b>(2)</a>
, <a href='sendmsg.2.html'><b>sendmsg</b>(2)</a>
,  <a href='recvfrom.2.html'><b>recvfrom</b>(2)</a>
, <a href='recvmsg.2.html'><b>recvmsg</b>(2)</a>
,
 <a href='poll.2.html'><b>poll</b>(2)</a>
, <a href='select.2.html'><b>select</b>(2)</a>
,  <a href='ioctl.2.html'><b>ioctl</b>(2)</a>
  
<p> 
<h2><a name='sect10' href='#toc10'>Author</a></h2>
Enea LINX team 
<h2><a name='sect11' href='#toc11'>Copyright</a></h2>

<p> Copyright
(c) 2006-2007, Enea Software AB All rights reserved. 
<p> Redistribution and
use in source and binary forms, with or without modification, are permitted
provided that the following conditions are met: 
<p> Redistributions of source
code must retain the above copyright notice, this list of conditions and
the following disclaimer. Redistributions in binary form must reproduce
the above copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the distribution.
Neither the name of Enea Software AB nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission. 
<p> THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Linx Concepts</a></li>
<li><a name='toc4' href='#sect4'>LINX Application Interfaces</a></li>
<li><a name='toc5' href='#sect5'>LINX Signals</a></li>
<li><a name='toc6' href='#sect6'>LINX Socket Interface</a></li>
<li><a name='toc7' href='#sect7'>IOCTL Request Codes</a></li>
<li><a name='toc8' href='#sect8'>Known Bugs</a></li>
<li><a name='toc9' href='#sect9'>See Also</a></li>
<li><a name='toc10' href='#sect10'>Author</a></li>
<li><a name='toc11' href='#sect11'>Copyright</a></li>
</ul>
</body>
</html>
